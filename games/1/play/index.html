<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Unity WebGL Player | nubik-slender</title>
		<link rel="shortcut icon" href="TemplateData/favicon.ico">
		<style>
			/* Remove focus outline on key press */
			canvas:focus {
				outline: none;
			}

			html, body {
				background-color: #222;
				/* Remove padding and margins */
				padding: 0;
				margin: 0;
				/* Disable scrolling and long tap on IOS */
				overflow: hidden;
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				-webkit-tap-highlight-color: rgba(0,0,0,0);
				/* Set height to 100% */
				height: 100%;
			}
		</style>
		<link rel="stylesheet" href="TemplateData/style.css">
	</head>
	<body>
		<div id="unity-container" style="width: 100%; height: 100%;">
			<canvas id="unity-canvas" width="auto" height="auto"></canvas>
			<div id="unity-loading-bar">
				<div id="unity-logo"></div>
				<div id="unity-progress-bar-empty">
					<div id="unity-progress-bar-full"></div>
				</div>
			</div>
			<div id="unity-warning"> </div>
			<div id="unity-footer">
				<div id="unity-webgl-logo"></div>
				<div id="unity-fullscreen-button"></div>
				<div id="unity-build-title">nubik-slender</div>
			</div>
		</div>
		<script>
			var container = document.querySelector("#unity-container");
			var canvas = document.querySelector("#unity-canvas");
			var loadingBar = document.querySelector("#unity-loading-bar");
			var progressBarFull = document.querySelector("#unity-progress-bar-full");
			var fullscreenButton = document.querySelector("#unity-fullscreen-button");
			var warningBanner = document.querySelector("#unity-warning");

			// Shows a temporary message banner/ribbon for a few seconds, or
			// a permanent error message on top of the canvas if type=='error'.
			// If type=='warning', a yellow highlight color is used.
			// Modify or remove this function to customize the visually presented
			// way that non-critical warnings and error messages are presented to the
			// user.
			function unityShowBanner(msg, type) {
				function updateBannerVisibility() {
					warningBanner.style.display = warningBanner.children.length ? 'block' : 'none';
				}
				var div = document.createElement('div');
				div.innerHTML = msg;
				warningBanner.appendChild(div);
				if (type == 'error') div.style = 'background: red; padding: 10px;';
				else {
					if (type == 'warning') div.style = 'background: yellow; padding: 10px;';
					setTimeout(function() {
						warningBanner.removeChild(div);
						updateBannerVisibility();
					}, 5000);
				}
				updateBannerVisibility();
			}

			var buildUrl = "Build";
			var loaderUrl = buildUrl + "/nubik-slender-webgl.loader.js";
			var config = {
				dataUrl: buildUrl + "/nubik-slender-webgl.data",
				frameworkUrl: buildUrl + "/nubik-slender-webgl.framework.js",
				codeUrl: buildUrl + "/nubik-slender-webgl.wasm",
				streamingAssetsUrl: "StreamingAssets",
				companyName: "DefaultCompany",
				productName: "nubik-slender",
				productVersion: "0.1",
				showBanner: unityShowBanner,
			};

			// By default Unity keeps WebGL canvas render target size matched with
			// the DOM size of the canvas element (scaled by window.devicePixelRatio)
			// Set this to false if you want to decouple this synchronization from
			// happening inside the engine, and you would instead like to size up
			// the canvas DOM size and WebGL render target sizes yourself.
			// config.matchWebGLToCanvasSize = false;

			if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
				// Mobile device style: fill the whole browser client area with the game canvas:

				var meta = document.createElement('meta');
				meta.name = 'viewport';
				meta.content = 'width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=yes';
				document.getElementsByTagName('head')[0].appendChild(meta);
				container.className = "unity-mobile";
				canvas.className = "unity-mobile";

				// To lower canvas resolution on mobile devices to gain some
				// performance, uncomment the following line:
				// config.devicePixelRatio = 1;

				// unityShowBanner('WebGL builds are not supported on mobile devices.');
			} else {
				// Desktop style: Render the game canvas in a window that can be maximized to fullscreen:

				canvas.style.width = "100%";
				canvas.style.height = "100%";
			}

			loadingBar.style.display = "block";

			var script = document.createElement("script");
			script.src = loaderUrl;
			script.onload = () => {
				createUnityInstance(canvas, config, (progress) => {
					progressBarFull.style.width = 100 * progress + "%";
				}).then((unityInstance) => {
					window.unityInstance = unityInstance;
					loadingBar.style.display = "none";
					fullscreenButton.onclick = () => {
						unityInstance.SetFullscreen(1);
					};
				}).catch((message) => {
					alert(message);
				});
			};
			document.body.appendChild(script);
		</script>
		<style>
			#verticalUnsupportedOverlay {
				position: fixed;
				left: 0;
				top: 0;
				width: 100%;
				height: 100%;
				background-color: #111;
				background-image: url('TemplateData/vertical.png');
				background-position: center;
				background-size: contain;
				background-repeat: no-repeat;
				z-index: 1000;
			}
		</style>
		<div id="verticalUnsupportedOverlay"></div>
		<script>
			// Set the display style of verticalUnsupportedOverlay based on the window dimensions
			verticalUnsupportedOverlay.style.display = window.innerWidth >= window.innerHeight ? 'none' : '';

			// Add event listeners for window resize and orientation change
			for (const type of ['resize', 'orientationchange']) {
				// When window is resized or orientation changes
				window.addEventListener(type, evt => {
					// If window is in landscape mode
					if (window.innerWidth >= window.innerHeight) {
						// Hide verticalUnsupportedOverlay
						verticalUnsupportedOverlay.style.display = 'none';
					} else {
						// Show verticalUnsupportedOverlay
						verticalUnsupportedOverlay.style.display = '';
						// Exit fullscreen if supported
						if (document.exitFullscreen) {
							document.exitFullscreen();
						}
					}
				});
			}

			// Function to toggle full screen mode
			function toggleFullScreen() {
				// Check if there is no element in full screen mode and the vertical unsupported overlay height is 0
				if (!document.fullscreenElement && verticalUnsupportedOverlay.offsetHeight === 0) {
					// Request full screen mode for the container element
					container.requestFullscreen();
				}
			}

			// Add event listener to trigger full screen mode on touch start
			window.addEventListener('touchstart', toggleFullScreen);
		</script>
		<script>
			document.onselectstart = function() { return false; };
			document.onmousedown = function() { return false; };

			function GetLang() {}
			function ShowFullscreenAdv() {}
			function ShowRewardedAdv() {}
			function SetLeaderBoard(score) {}
			function GetLeaderBoardEntries() {}

			function setControlsVisible(value) {}
			function changeSeed(value) {
				value = value.toString();
				if (value === '0') {
					value = '';
				}

				if (navigator.userAgent.includes('Firefox')) {
					value = prompt('', value);
					if (value === '') { value = '0'; }
					unityInstance.SendMessage('BonusMenu', 'SeedChanged', value);
				} else {
					customPrompt('', value, value => {
						if (value === '') { value = '0'; }
						unityInstance.SendMessage('BonusMenu', 'SeedChanged', value);
					});
				}
			}

			if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
				const container = (function mobileControls() {
					function addResizeEventListener(listener) {
						listener();
						window.addEventListener('resize', listener);
						window.addEventListener('orientationchange', listener);
					}

					const unityContainer = document.getElementById('unity-container');
					let ratio, sqrRatio, neutralRatioSize;
					addResizeEventListener(evt => {
						ratio = unityContainer.clientWidth / unityContainer.clientHeight;
						sqrRatio = Math.sqrt(ratio);
						neutralRatioSize = unityContainer.clientWidth / sqrRatio;
					});

					const container = document.createElement('div');
					container.setAttribute('style', 'display: none; position: absolute; left: 0px; top: 0px; width: 100%; height: 100%; pointer-events: none; user-select: none;');
						const movementArea = document.createElement('div');
						movementArea.setAttribute('style', 'position: absolute; left: 0px; top: 0px; width: 50%; height: 100%; pointer-events: auto; user-select: none;');
						container.appendChild(movementArea);

						const joystickContainer = document.createElement('div');
						joystickContainer.setAttribute('style', 'display: none; position: absolute; transform: translateX(-50%) translateY(-50%); border-radius: 100%; background-color: #7f7f7f; opacity: 0.5; pointer-events: auto; user-select: none;');
						addResizeEventListener(evt => {
							joystickContainer.style.width = `${40 / sqrRatio}%`;
							joystickContainer.style.height = `${40 * sqrRatio}%`;
						});
							const joystickInput = { horizontal: 0, vertical: 0, maxLen: 1 };
							(function sendJoystickInput() {
								if (window.unityInstance && container.offsetHeight > 0) {
									unityInstance.SendMessage(
										'Player',
										'OnJoystickInput',
										(joystickInput.horizontal + ' ' + joystickInput.vertical + ' ' + joystickInput.maxLen).replaceAll('.', ',')
									);
								}
								requestAnimationFrame(sendJoystickInput);
							})();
							const joystick = document.createElement('joystick');
							joystick.setAttribute('style', 'position: absolute; left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%); width: 50%; height: 50%; border-radius: 100%; background-color: #3f3f3f; user-select: none;');
							let joystickMoving = false, joystickStartX = 0, joystickStartY = 0;
							movementArea.addEventListener('touchstart', evt => {
								evt.preventDefault();
								let touch = null;
								for (const t of evt.touches) {
									if (t.target === movementArea) {
										touch = t;
										break;
									}
								}
								if (touch !== null) {
									joystickStartX = touch.clientX;
									joystickStartY = touch.clientY;
									joystickContainer.style.left = joystickStartX + 'px';
									joystickContainer.style.top = joystickStartY + 'px';
									joystickContainer.style.display = '';
									joystickMoving = true;
								}
							});
							movementArea.addEventListener('touchend', evt => {
								evt.preventDefault();
								joystickMoving = false;
								joystick.style.marginLeft = '0px';
								joystick.style.marginTop = '0px';
								joystickInput.horizontal = 0;
								joystickInput.vertical = 0;
								joystickInput.maxLen = 1;
								joystickContainer.style.display = 'none';
							});
							movementArea.addEventListener('touchmove', evt => {
								evt.preventDefault();
								let touch = null;
								for (const t of evt.touches) {
									if (t.target === movementArea) {
										touch = t;
										break;
									}
								}
								if (touch !== null && joystickMoving) {
									const maxLen = joystickContainer.clientWidth * 0.5;
									let dx = touch.clientX - joystickStartX,
										dy = touch.clientY - joystickStartY,
										len = Math.hypot(dx, dy);
									if (len > maxLen) {
										dx = dx * maxLen / len;
										dy = dy * maxLen / len;
									}
									joystick.style.marginLeft = `${dx}px`;
									joystick.style.marginTop = `${dy}px`;
									joystickInput.horizontal = dx;
									joystickInput.vertical = -dy;
									joystickInput.maxLen = maxLen;
								}
							});
							joystickContainer.appendChild(joystick);
						container.appendChild(joystickContainer);

						const lookArea = document.createElement('div');
						lookArea.setAttribute('style', 'position: absolute; left: 50%; top: 0px; width: 50%; height: 100%; pointer-events: auto; user-select: none;');
						const touchInput = { x: 0, y: 0 };
						let lookAreaPreviousTouch = null;
						(function sendTouchInput() {
							if (window.unityInstance && container.offsetHeight > 0) {
								unityInstance.SendMessage(
									'PlayerCam',
									'OnTouchInput',
									(touchInput.x + ' ' + touchInput.y).replaceAll('.', ',')
								);
								touchInput.x = 0;
								touchInput.y = 0;
							}
							requestAnimationFrame(sendTouchInput);
						})();
						lookArea.addEventListener('touchmove', evt => {
							evt.preventDefault();
							let touch = null;
							for (const t of evt.touches) {
								if (t.target === lookArea) {
									touch = t;
									break;
								}
							}
							if (touch !== null) {
								if (lookAreaPreviousTouch !== null) {
									touchInput.x = touch.clientX - lookAreaPreviousTouch.clientX;
									touchInput.y = -touch.clientY + lookAreaPreviousTouch.clientY;
								}
								lookAreaPreviousTouch = touch;
							}
						});
						lookArea.addEventListener('touchend', evt => {
							lookAreaPreviousTouch = null;
						});
						container.appendChild(lookArea);

						const interactBtn = document.createElement('div');
						interactBtn.textContent = 'I';
						interactBtn.setAttribute('style', 'position: absolute; border-radius: 100%; background-color: #7f7f7f; opacity: 0.5; color: white; text-align: center; vertical-align: middle; pointer-events: auto; user-select: none;');
						addResizeEventListener(evt => {
							interactBtn.style.top = `${10 * sqrRatio}%`;
							interactBtn.style.right = `${5 / sqrRatio}%`;
							interactBtn.style.width = `${15 / sqrRatio}%`;
							interactBtn.style.height = `${15 * sqrRatio}%`;
							interactBtn.style.fontSize = `${neutralRatioSize * 0.12}px`;
						});
						let interactBtnActiveTimeout = null;
						interactBtn.addEventListener('touchstart', evt => {
							evt.preventDefault();
							if (interactBtnActiveTimeout !== null) {
								clearTimeout(interactBtnActiveTimeout);
							}
							interactBtn.style.backgroundColor = '#afafaf';
							interactBtnActiveTimeout = setTimeout(() => {
								interactBtnActiveTimeout = null;
								interactBtn.style.backgroundColor = '#7f7f7f';
							}, 125)
							unityInstance.SendMessage('Player', 'OnInteract');
						});
						container.appendChild(interactBtn);

						const jumpBtn = document.createElement('div');
						jumpBtn.textContent = 'J';
						jumpBtn.setAttribute('style', 'position: absolute; border-radius: 100%; background-color: #7f7f7f; opacity: 0.5; color: white; text-align: center; vertical-align: middle; pointer-events: auto; user-select: none;');
						addResizeEventListener(evt => {
							jumpBtn.style.top = `${30 * sqrRatio}%`;
							jumpBtn.style.right = `${5 / sqrRatio}%`;
							jumpBtn.style.width = `${15 / sqrRatio}%`;
							jumpBtn.style.height = `${15 * sqrRatio}%`;
							jumpBtn.style.fontSize = `${neutralRatioSize * 0.12}px`;
						});
						let jumpBtnActiveTimeout = null;
						jumpBtn.addEventListener('touchstart', evt => {
							evt.preventDefault();
							if (jumpBtnActiveTimeout !== null) {
								clearTimeout(jumpBtnActiveTimeout);
							}
							jumpBtn.style.backgroundColor = '#afafaf';
							jumpBtnActiveTimeout = setTimeout(() => {
								jumpBtnActiveTimeout = null;
								jumpBtn.style.backgroundColor = '#7f7f7f';
							}, 166)
							unityInstance.SendMessage('Player', 'OnJump');
						});
						container.appendChild(jumpBtn);
					unityContainer.insertAdjacentElement('afterBegin', container);
					return container;
				})();

				window.setControlsVisible = function(value) {
					container.style.display = value ? '' : 'none';
				};
			}

			const oRequestPointerLock = Element.prototype.requestPointerLock;
			Element.prototype.requestPointerLock = function requestPointerLockHk() {
				return new Promise(async resolve => {
					try {
						const args = [...arguments];
						args[0] = args[0] || {};
						args[0].unadjustedMovement = true;
						await oRequestPointerLock.apply(this, args);
					} catch(err) {
						console.log(err);
					}
					resolve();
				});
			};

			function customPrompt(message, defaultValue, callback) {
				// Check if style element already exists
				let styleElement = document.getElementById('custom-prompt-styles');

				if (!styleElement) {
					// Create styles dynamically
					const styles = `
						body {
							margin: 0;
							font-family: Arial, sans-serif;
						}

						#custom-prompt-overlay {
							display: none;
							position: fixed;
							top: 0;
							left: 0;
							width: 100%;
							height: 100%;
							background: rgba(0, 0, 0, 0.7);
							justify-content: center;
							align-items: center;
							z-index: 9999;
						}

						#custom-prompt-container {
							background: #222;
							color: #fff;
							padding: 20px;
							border-radius: 5px;
							max-width: 400px;
							text-align: center;
						}

						#custom-prompt-input {
							width: 100%;
							padding: 8px;
							margin-bottom: 15px;
							box-sizing: border-box;
						}

						#custom-prompt-buttons {
							display: flex;
							justify-content: space-between;
						}

						#custom-prompt-buttons button {
							flex-grow: 1;
							margin: 0 5px;
							padding: 10px;
							cursor: pointer;
							border: none;
							border-radius: 5px;
						}

						#custom-prompt-ok {
							background-color: #000;
							color: #fff;
						}

						#custom-prompt-cancel {
							background-color: #333;
							color: #fff;
						}
					`;

					// Create a style element and append it to the head
					styleElement = document.createElement('style');
					styleElement.id = 'custom-prompt-styles';
					styleElement.innerHTML = styles;
					document.head.appendChild(styleElement);
				}

				// Create overlay
				const overlay = document.createElement('div');
				overlay.id = 'custom-prompt-overlay';

				// Create container
				const container = document.createElement('div');
				container.id = 'custom-prompt-container';

				// Create input field
				const inputField = document.createElement('input');
				inputField.id = 'custom-prompt-input';
				inputField.type = 'text';
				inputField.value = defaultValue;

				// Create buttons
				const buttonsContainer = document.createElement('div');
				buttonsContainer.id = 'custom-prompt-buttons';

				const okButton = document.createElement('button');
				okButton.id = 'custom-prompt-ok';
				okButton.innerHTML = 'OK';

				const cancelButton = document.createElement('button');
				cancelButton.id = 'custom-prompt-cancel';
				cancelButton.innerHTML = 'Cancel';

				// Append elements to the body
				document.body.appendChild(overlay);
				overlay.appendChild(container);
				container.innerHTML = `<p>${message}</p>`;
				container.appendChild(inputField);
				buttonsContainer.appendChild(okButton);
				buttonsContainer.appendChild(cancelButton);
				container.appendChild(buttonsContainer);

				// Set up button click events
				okButton.addEventListener('click', () => {
					closePrompt();
					// Execute callback with the input value if provided
					if (typeof callback === 'function') {
						callback(inputField.value);
					}
				});

				cancelButton.addEventListener('click', () => {
				closePrompt();
					// Execute callback with null to indicate cancel
					if (typeof callback === 'function') {
						callback(null);
					}
				});

				// Set up Enter key press event in the input field
				inputField.addEventListener('keydown', (event) => {
					if (event.key === 'Enter') {
						event.preventDefault(); // Prevent the default behavior of the Enter key in the input field
						okButton.click(); // Simulate a click on the OK button
					}
				});

				// Display the overlay
				overlay.style.display = 'flex';

				// Function to close the prompt
				function closePrompt() {
					// Remove elements
					overlay.style.display = 'none';
					document.body.removeChild(overlay);
				}
			}
		</script>
	</body>
</html>
